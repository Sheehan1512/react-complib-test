import l from "path";
import a from "fs";
import p from "picocolors";
import u from "magic-string";
function y(c) {
  let n = !1;
  return {
    name: "vite:lib-inject-css",
    apply: "build",
    enforce: "post",
    config() {
      const { rollupOptions: s = {}, build: e, ...i } = c || {};
      let t = s.output;
      return t = [t].flat().map((o) => ({
        /**
         * By default, when creating multiple chunks, transitive imports of entry chunks will be added as empty imports to the entry chunks.
         * @see https://rollupjs.org/faqs/#why-do-additional-imports-turn-up-in-my-entry-chunks-when-code-splitting
         * But as a library, this option may cause tree-shaking fails, so we set `false` here as default behavior.
         */
        hoistTransitiveImports: !1,
        ...o
      })), s.output = t.length === 1 ? t[0] : t, {
        build: {
          ...e,
          lib: i,
          rollupOptions: s,
          /**
           * Must enable css code split, otherwise there's only one `style.css` and `chunk.viteMetadata.importedCss` will be empty.
           * @see https://github.com/vitejs/vite/blob/HEAD/packages/vite/src/node/plugins/css.ts#L613
           */
          cssCodeSplit: !0,
          /**
           * Must emit assets on SSR, otherwise there won't be any CSS files generated and the import statements
           * injected by this plugin will refer to an undefined module.
           * @see https://github.com/vitejs/vite/blob/HEAD/packages/vite/src/node/plugins/asset.ts#L213-L218
           */
          ssrEmitAssets: !0
        }
      };
    },
    configResolved({ build: s }) {
      const e = [], i = [s.rollupOptions.output].flat();
      s.lib || (n = !0, e.push("Current build is not in library mode, skip code injection.")), s.lib && s.cssCodeSplit === !1 && e.push(
        "`config.build.cssCodeSplit` is set to `true` by the plugin internally in library mode, but it seems to be `false` now. This may cause style code injection to fail, please check the configuration to prevent this option from being modified."
      ), s.ssr && s.ssrEmitAssets === !1 && e.push(
        "`config.build.ssrEmitAssets` is set to `true` by the plugin internally in library mode, but it seems to be `false` now. This may cause style code injection to fail on SSR, please check the configuration to prevent this option from being modified."
      );
      const t = (o) => {
        e.push(
          "When `" + o + "` is `true`, the association between chunk file and its css references will lose, so the style code injection will be skipped."
        );
      };
      i.some((o) => (o == null ? void 0 : o.preserveModules) === !0) && (n = !0, t("rollupOptions.output.preserveModules")), s.rollupOptions.preserveModules === !0 && (n = !0, t("rollupOptions.preserveModules")), e.forEach((o) => console.log(`
${p.cyan("[vite:lib-inject-css]:")} ${p.yellow(o)}
`));
    },
    renderChunk(s, e) {
      if (n || !e.viteMetadata)
        return;
      const { importedCss: i } = e.viteMetadata;
      if (!i.size)
        return;
      const t = new u(s);
      for (const o of i) {
        let r = l.relative(l.dirname(e.fileName), o).replaceAll(/[\\/]+/g, "/");
        r = r.startsWith(".") ? r : `./${r}`, t.prepend(`import '${r}';
`);
      }
      return {
        code: t.toString(),
        map: t.generateMap()
      };
    }
  };
}
function b(c) {
  const n = {}, s = {};
  for (const e of [c].flat()) {
    if (!e)
      break;
    const i = a.statSync(e).isDirectory() ? a.readdirSync(e).map((t) => l.resolve(e, t)) : [e];
    for (const t of i) {
      const { name: o } = l.parse(t), r = s[o] || 0;
      n[`${o}${r || ""}`] = t, s[o] = r + 1;
    }
  }
  return n;
}
export {
  y as libInjectCss,
  b as scanEntries
};
